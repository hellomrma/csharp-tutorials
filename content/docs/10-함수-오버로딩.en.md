---
title: Function Overloading
titleEn: Function Overloading
description: Learn about function overloading in C#. Understand how to create multiple functions with the same name but different parameters.
descriptionEn: Learn about function overloading in C#. Understand how to create multiple functions with the same name but different parameters.
category: Unity C# Basics
categoryEn: Unity C# Basics
order: 10
---

# 10. Function Overloading

## What is Overloading?

You can create multiple functions with the same name, but they must have different parameter types or counts. This is called function overloading. Very useful in Unity for creating functions that work in various situations.

```csharp
public class Player : MonoBehaviour
{
    // Function with 2 parameters: base damage and weapon power
    int CalculateDamage(int baseDamage, int weaponPower)
    {
        return baseDamage + weaponPower;
    }
    
    // Function with 1 parameter (overloaded): base damage only
    int CalculateDamage(int baseDamage)
    {
        return baseDamage;  // No weapon, base damage only
    }
    
    // Function with different parameter types (overloaded): float type
    float CalculateDamage(float baseDamage, float weaponPower)
    {
        return baseDamage + weaponPower;  // Decimal damage calculation
    }
    
    // Function with 3 parameters: add critical multiplier
    int CalculateDamage(int baseDamage, int weaponPower, float criticalMultiplier)
    {
        int total = baseDamage + weaponPower;
        return Mathf.RoundToInt(total * criticalMultiplier);
    }
}
```

## Usage Example

```csharp
void Start()
{
    // With weapon
    int damage1 = CalculateDamage(10, 5);  // 15 (int, int)
    Debug.Log("Damage: " + damage1);
    
    // Without weapon
    int damage2 = CalculateDamage(10);  // 10 (int)
    Debug.Log("Damage: " + damage2);
    
    // Decimal damage
    float damage3 = CalculateDamage(10.5f, 5.2f);  // 15.7 (float, float)
    Debug.Log("Damage: " + damage3);
    
    // With critical hit
    int damage4 = CalculateDamage(10, 5, 2.0f);  // 30 (critical 2x)
    Debug.Log("Critical damage: " + damage4);
}
```

## Advantages of Overloading

- **Flexibility**: Same functionality but can accept different types or counts of values
  - Example: `Attack()` - basic attack, `Attack(int damage)` - attack with specified damage
- **Convenience**: Can unify function names, making them easier to remember
  - Example: Unify all attack-related functions as `Attack`
- **Readability**: Code is cleaner and easier to understand
  - Example: `Attack()`, `Attack(target)`, `Attack(target, damage)` all have the same meaning

**Actual usage in game development:**
```csharp
public class CombatSystem : MonoBehaviour
{
    // Basic attack
    void Attack()
    {
        Attack(GetDefaultDamage());
    }
    
    // Attack with target
    void Attack(GameObject target)
    {
        Attack(target, GetDefaultDamage());
    }
    
    // Attack with target and damage
    void Attack(GameObject target, int damage)
    {
        Enemy enemy = target.GetComponent<Enemy>();
        if (enemy != null)
        {
            enemy.TakeDamage(damage);
        }
    }
    
    int GetDefaultDamage() { return 10; }
}
```

## Overloading Rules

1. **Function names must be the same**
2. **Parameter types or counts must be different**
3. **Cannot overload with only different return types** (causes error)

```csharp
// ✅ Possible: Different parameter counts
int Add(int a, int b) { return a + b; }
int Add(int a, int b, int c) { return a + b + c; }

// ✅ Possible: Different parameter types
int Add(int a, int b) { return a + b; }
float Add(float a, float b) { return a + b; }

// ❌ Not possible: Only return type differs (error!)
int Add(int a, int b) { return a + b; }
float Add(int a, int b) { return a + b; }  // Compile error!
```

---

[← Back to Table of Contents](../README.md)

