---
title: 클래스와 상속
titleEn: Classes and Inheritance
slugEn: 11-classes-and-inheritance
description: C#의 클래스와 상속을 학습합니다. 클래스를 만들고 상속을 사용하여 코드를 효율적으로 재사용하는 방법을 이해합니다.
descriptionEn: Learn about classes and inheritance in C#. Understand how to create classes and use inheritance to reuse code efficiently.
category: Unity C# 기초
categoryEn: Unity C# Basics
order: 11
---

# 11. 클래스와 상속

## 클래스란?

클래스는 변수와 함수를 묶어서 하나의 객체를 만드는 설계도입니다. 게임에서 플레이어, 적, 아이템 등을 만들 때 사용합니다. Unity에서는 `MonoBehaviour`를 상속받아 게임 오브젝트의 동작을 정의합니다.

```csharp
public class Player : MonoBehaviour
{
    // 변수 (필드)
    public string playerName = "플레이어";
    public int hp = 100;
    public int level = 1;
    
    // 함수 (메서드)
    public void Attack()
    {
        Debug.Log(playerName + "이(가) 공격합니다!");
    }
    
    public void TakeDamage(int damage)
    {
        hp -= damage;
        Debug.Log("데미지 " + damage + " 받음! 남은 체력: " + hp);
    }
    
    private void LevelUp()
    {
        level++;
        Debug.Log("레벨업! 현재 레벨: " + level);
    }
}
```

## 상속이란?

상속은 기존 클래스의 기능을 그대로 가져와서 새로운 클래스를 만드는 방법입니다. 부모 클래스의 모든 변수와 함수를 자식 클래스에서 사용할 수 있습니다. 게임에서 다양한 적이나 무기를 만들 때 공통 기능을 재사용할 수 있습니다.

```csharp
// 부모 클래스 (Enemy) - 모든 적의 공통 기능
public class Enemy : MonoBehaviour
{
    public string enemyName;
    public int hp = 50;
    public int damage = 10;
    
    public void Attack()
    {
        Debug.Log(enemyName + "이(가) 공격합니다! 데미지: " + damage);
    }
    
    public void TakeDamage(int damageAmount)
    {
        hp -= damageAmount;
        Debug.Log(enemyName + "이(가) 데미지 " + damageAmount + " 받음!");
        
        if (hp <= 0)
        {
            Die();
        }
    }
    
    public virtual void Die()
    {
        Debug.Log(enemyName + "이(가) 죽었습니다.");
    }
}

// 자식 클래스 (Goblin) - Enemy를 상속받음
public class Goblin : Enemy
{
    void Start()
    {
        enemyName = "고블린";  // 부모 클래스의 변수 사용 가능
        hp = 30;               // 부모 클래스의 변수 수정 가능
        damage = 5;
    }
    
    // 부모 클래스의 함수 재정의 (override)
    public override void Die()
    {
        Debug.Log("고블린이 비명을 지르며 쓰러집니다!");
        // 추가 효과: 아이템 드롭, 경험치 지급 등
    }
}

// 자식 클래스 (Orc) - Enemy를 상속받음
public class Orc : Enemy
{
    void Start()
    {
        enemyName = "오크";
        hp = 100;  // 오크는 체력이 더 많음
        damage = 20;  // 오크는 공격력이 더 높음
    }
    
    public override void Die()
    {
        Debug.Log("오크가 큰 소리를 내며 쓰러집니다!");
    }
}
```

## 상속의 장점

- **코드 재사용**: 부모 클래스의 코드를 다시 작성할 필요 없음
  - 예: 모든 적이 `Attack()`, `TakeDamage()` 함수를 공유
- **일관성**: 비슷한 객체들이 같은 기능을 공유
  - 예: 모든 무기가 `Use()` 함수를 가짐
- **유지보수**: 부모 클래스만 수정하면 모든 자식 클래스에 적용
  - 예: `Enemy` 클래스의 `TakeDamage()` 수정 시 모든 적에 적용

## 실전 예시: 무기 클래스

```csharp
// 부모 클래스: Weapon (모든 무기의 공통 기능)
public class Weapon : MonoBehaviour
{
    public string weaponName;
    public int damage;
    public float attackSpeed;
    
    public virtual void Attack()
    {
        Debug.Log(weaponName + "으로 공격! 데미지: " + damage);
    }
    
    public void Equip()
    {
        Debug.Log(weaponName + "을(를) 장착했습니다.");
    }
}

// 자식 클래스: Sword (Weapon을 상속받음)
public class Sword : Weapon
{
    void Start()
    {
        weaponName = "철검";
        damage = 20;
        attackSpeed = 1.0f;
    }
    
    // 부모 클래스의 함수 재정의
    public override void Attack()
    {
        Debug.Log("검으로 베기 공격! 데미지: " + damage);
    }
}

// 자식 클래스: Bow (Weapon을 상속받음)
public class Bow : Weapon
{
    void Start()
    {
        weaponName = "장궁";
        damage = 15;
        attackSpeed = 1.5f;
    }
    
    public override void Attack()
    {
        Debug.Log("활로 원거리 공격! 데미지: " + damage);
    }
}

// 자식 클래스: Staff (Weapon을 상속받음)
public class Staff : Weapon
{
    void Start()
    {
        weaponName = "마법 지팡이";
        damage = 25;
        attackSpeed = 0.8f;
    }
    
    public override void Attack()
    {
        Debug.Log("마법 공격! 데미지: " + damage);
    }
}
```

## 상속 관계 표현

- **부모 클래스 (Parent Class)**: 상속을 해주는 클래스 (Human, Car)
- **자식 클래스 (Child Class)**: 상속을 받는 클래스 (GwangSeub, BMW)
- **상속 문법**: `class 자식클래스 : 부모클래스`

---

[← 목차로 돌아가기](../README.md)

