---
title: Fields & Properties
titleEn: Fields & Properties
description: Learn about fields (variables) and properties in C#. Understand when to use each and how to control access with properties.
descriptionEn: Learn about fields (variables) and properties in C#. Understand when to use each and how to control access with properties.
category: Unity C# Basics
categoryEn: Unity C# Basics
order: 17
---

# 17. Fields & Properties

## Fields and Properties

There are two ways to store data in a class:
1. **Fields (Variables)**: For internal use only
2. **Properties**: When control is needed for external read/write

## Fields

Fields are data used directly within a class.

### Basic Usage
```csharp
public class Player
{
    public int score;      // Accessible from outside
    private int bonus;     // Accessible only internally
}
```

### Characteristics
- Simple and fast
- Can directly read and write values
- No control or validation possible

## Properties

Properties look like variables but can **control reading (get) and writing (set)**.

### Basic Syntax
```csharp
public class Player
{
    private int score;  // Internal variable (usually private)
    
    public int Score    // Property (starts with capital letter)
    {
        get { return score; }      // Read
        set { score = value; }     // Write (value is automatically passed)
    }
}
```

### Usage Example
```csharp
Player player = new Player();
player.Score = 100;        // Calls set (value = 100)
int currentScore = player.Score;  // Calls get
```

## Uses of Properties

### 1. Encapsulation
Hide internal variables and access through properties.

```csharp
public class Player
{
    private int health;  // Cannot access directly from outside
    
    public int Health    // Only accessible through property
    {
        get { return health; }
        set { health = value; }
    }
}
```

### 2. Validation
Can validate values when setting them.

```csharp
public class Player
{
    private int health = 100;
    
    public int Health
    {
        get { return health; }
        set 
        {
            // Only allow values between 0~100
            if (value < 0)
                health = 0;
            else if (value > 100)
                health = 100;
            else
                health = value;
        }
    }
}
```

### 3. Calculated Values
Can return calculated values.

```csharp
public class Player
{
    public int score = 10;
    public int bonus = 5;
    
    public int TotalScore  // Read-only property
    {
        get { return score + bonus; }  // Return calculated value
    }
}

// Usage
Player player = new Player();
Debug.Log(player.TotalScore);  // Outputs 15 (10 + 5)
```

## Read-Only Properties

Omitting `set` makes it read-only.

```csharp
public class Player
{
    private int level = 1;
    
    public int Level
    {
        get { return level; }  // No set, so read-only
    }
}
```

## Auto-Implemented Properties

Simple properties can be written more concisely.

### Regular Property
```csharp
private string name;

public string Name
{
    get { return name; }
    set { name = value; }
}
```

### Auto-Implemented Property
```csharp
public string Name { get; set; }  // Much simpler!
```

Automatically creates internal variable and handles get/set.

### Read-Only Auto Property
```csharp
public string Name { get; private set; }  // Read-only from outside
```

## Fields vs Properties Comparison

| Feature | Fields | Properties |
|---------|--------|------------|
| When to use | Internal use only | External access control needed |
| Validation | Not possible | Possible (in set) |
| Calculation | Not possible | Possible (in get) |
| Code length | Short | Relatively long |
| Performance | Slightly faster | Slightly slower (negligible) |

## Practical Usage Examples

### Example 1: Score Management
```csharp
public class Player
{
    public int score;
    public int bonus;
    
    // Return calculated total score
    public int TotalScore
    {
        get { return score + bonus; }
    }
}

// Usage
Player player = new Player();
player.score = 10;
player.bonus = 5;
Debug.Log("Total: " + player.TotalScore);  // Outputs 15
```

### Example 2: Health Limit
```csharp
public class Player
{
    private int health = 100;
    
    public int Health
    {
        get { return health; }
        set 
        {
            // Limit between 0~100
            health = Mathf.Clamp(value, 0, 100);
        }
    }
}

// Usage
Player player = new Player();
player.Health = 150;  // Limited to 100
player.Health = -10;  // Limited to 0
```

### Example 3: Auto-Implemented Properties
```csharp
public class Weapon
{
    public string Name { get; set; }
    public int Damage { get; set; }
    public int Durability { get; private set; }  // Read-only
}
```

## When to Use What?

### Use Fields
- Use only within class
- Simple data storage
- When control is not needed

### Use Properties
- When external access is needed
- When value validation is needed
- When calculated values need to be returned
- When read/write needs to be controlled

## Notes

1. **Property names start with capital letter** (generally)
2. **Internal variables should be private** for hiding
3. **Auto-implemented properties** only for simple cases
4. **Use regular properties** when calculation is complex

---

[‚Üê Back to Table of Contents](../README.md)

